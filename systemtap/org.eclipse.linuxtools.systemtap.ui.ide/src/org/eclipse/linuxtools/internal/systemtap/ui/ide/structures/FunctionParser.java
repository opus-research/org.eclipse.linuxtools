/*******************************************************************************
 * Copyright (c) 2006,2012 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - Jeff Briggs, Henry Hughes, Ryan Morse
 *******************************************************************************/

package org.eclipse.linuxtools.internal.systemtap.ui.ide.structures;

import java.text.MessageFormat;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.linuxtools.internal.systemtap.ui.ide.CommentRemover;
import org.eclipse.linuxtools.internal.systemtap.ui.ide.IDEPlugin;
import org.eclipse.linuxtools.systemtap.structures.FunctionNodeData;
import org.eclipse.linuxtools.systemtap.structures.TreeDefinitionNode;
import org.eclipse.linuxtools.systemtap.structures.TreeNode;

/**
 * Runs stap -vp1 & stap -up2 in order to get all of the probes/functions
 * that are defined in the tapsets.  Builds probeAlias and function trees
 * with the values obtained from the tapsets.
 *
 * Ugly code is a result of two issues with getting stap output.  First,
 * many tapsets do not work under stap -up2.  Second since the output
 * is not a regular language, we can't create a nice lexor/parser combination
 * to do everything nicely.
 * @author Ryan Morse
 * @since 2.0
 */
public class FunctionParser extends TapsetParser {

	private TreeNode functions;
	static FunctionParser parser = null;

	public static FunctionParser getInstance(){
		if (parser != null) {
			return parser;
		}
		parser = new FunctionParser();
		return parser;
	}

	private FunctionParser() {
		super("Function Parser"); //$NON-NLS-1$
		functions = new TreeNode("", false); //$NON-NLS-1$
	}

	/**
	 * Returns the root node of the tree of functions generated by
	 * parseFiles.  Functions are grouped by source file.
	 * @return A tree of tapset functions grouped by file.
	 */
	public synchronized TreeNode getFunctions() {
		return functions;
	}

	@Override
	protected IStatus run(IProgressMonitor monitor) {
		runPass2Functions();
		functions.sortTree();
		fireUpdateEvent();	//Inform listeners that everything is done
		return new Status(IStatus.OK, IDEPlugin.PLUGIN_ID, ""); //$NON-NLS-1$
	}

	/**
	 * This method is used to build up the list of functions that were found
	 * during the first pass of stap.  Stap is invoked by: $stap -v -p1 -e
	 * 'probe begin{}' and parsing the output.
	 */
	private void runPass2Functions() {
		String script = "probe begin{}"; //$NON-NLS-1$
		String result = runStap(new String[] {"-v", "-p1", "-e"}, script, false);   //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
		if (result == null) {
			return;
		}
		StringTokenizer st = new StringTokenizer(result, "\n", false); //$NON-NLS-1$
		st.nextToken(); //skip that stap command
		String tok = ""; //$NON-NLS-1$
		String filename = null;
		String scriptText = null;

		String functionRegex = "(?s)(?<!\\w)function\\s+({0})(?:\\s*:\\s*(\\w+))?\\s*\\(([^)]+?)?\\)"; //$NON-NLS-1$
		// Get functions (with proper typing) directly from the .stp files being used by stap.
		Pattern pFilename = Pattern.compile("# file (/.*\\.stp)"); //$NON-NLS-1$
		Pattern pFunction = Pattern.compile("function (?!_)(\\w+) \\(.*?\\)"); //Ignore functions starting with _. //$NON-NLS-1$
		Pattern pParams = Pattern.compile("(\\w+)(?:\\s*:\\s*(\\w+))?"); //$NON-NLS-1$
		Pattern pAllCaps = Pattern.compile("[A-Z_1-9]*"); //$NON-NLS-1$
		Pattern pReturn = Pattern.compile("\\sreturn\\W"); //$NON-NLS-1$

		while(st.hasMoreTokens()) {
			tok = st.nextToken();
			Matcher mFilename = pFilename.matcher(tok);
			if(mFilename.matches()) {
				filename = mFilename.group(1).toString();
				scriptText = null;
			} else if (filename != null) {
				Matcher mFunction = pFunction.matcher(tok);
				if(mFunction.matches()) {
					// Ignore ALL_CAPS functions, since they are not meant for end-user use.
					String functionName = mFunction.group(1);
					if (pAllCaps.matcher(functionName).matches()) {
						continue;
					}
					if (scriptText == null) {
						scriptText = CommentRemover.execWithFile(filename);
					}
					Matcher mScript = Pattern.compile(MessageFormat.format(functionRegex, functionName)).matcher(scriptText);
					while (mScript.find()) {
						String functionLine = mScript.group();
						String functionType = mScript.group(2);
						// If the function has no return type, look for a "return" statement to check
						// if it's really a void function, or if its return type is just unspecified
						if (functionType == null && searchForPattern(scriptText, mScript.end(), pReturn)) {
							functionType = FunctionNodeData.UNKNOWN_TYPE;
						}
						TreeDefinitionNode function = new TreeDefinitionNode(
								new FunctionNodeData(functionLine, functionType),
								functionName, filename, true);
						functions.add(function);
						// Add all function parameters that exist
						String params = mScript.group(3);
						if (params != null) {
							Matcher mParams = pParams.matcher(params);
							while (mParams.find()) {
								function.add(new TreeNode(
										new FunctionNodeData(null, mParams.group(2)),
										mParams.group(1), false));
							}
						}
					}
				}
			}
		}
		functions.sortTree();
	}

	private boolean searchForPattern(String scriptText, int start, Pattern p) {
		int end, bcount = 1;
		start = scriptText.indexOf('{', start) + 1;
		for (end = start; end < scriptText.length(); end++) {
			char c = scriptText.charAt(end);
			if (c == '{') {
				bcount++;
			} else if (c == '}' && --bcount == 0) {
				break;
			}
		}
		return p.matcher(scriptText.substring(start, end)).find();
	}

	/**
	 * This method will clean up everything from the run.
	 */
	public void dispose() {
		functions.dispose();
	}

}
