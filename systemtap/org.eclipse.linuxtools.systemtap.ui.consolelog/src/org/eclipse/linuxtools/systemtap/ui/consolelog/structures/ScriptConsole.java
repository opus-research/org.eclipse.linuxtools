/*******************************************************************************
 * Copyright (c) 2006 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - Jeff Briggs, Henry Hughes, Ryan Morse
 *******************************************************************************/

package org.eclipse.linuxtools.systemtap.ui.consolelog.structures;

import java.io.File;
import java.io.IOException;

import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.linuxtools.systemtap.ui.consolelog.ScpExec;
import org.eclipse.linuxtools.systemtap.ui.consolelog.internal.Localization;
import org.eclipse.linuxtools.systemtap.ui.consolelog.views.ErrorView;
import org.eclipse.linuxtools.systemtap.ui.structures.IPasswordPrompt;
import org.eclipse.linuxtools.systemtap.ui.structures.runnable.LoggedCommand;
import org.eclipse.linuxtools.tools.launch.core.factory.RuntimeProcessFactory;
import org.eclipse.ui.IViewPart;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.console.ConsolePlugin;
import org.eclipse.ui.console.IOConsole;



/**
 * This class serves as a pain in the ConsoleView.  It is used to create a new Command that,
 * through ConsoleDaemons will print all the output the the console.  In order to stop the
 * running Command <code>StopScriptAction</code> should be used to stop this console from
 * running.
 * @author Ryan Morse
 */
public class ScriptConsole extends IOConsole {

	private LoggedCommand cmd;
	private Runnable stopCommand;
	private String moduleName;

	private ErrorStreamDaemon errorDaemon;
	private ConsoleStreamDaemon consoleDaemon;

	ScriptConsole(String name, ImageDescriptor imageDescriptor) {
		super(name, imageDescriptor);
		cmd = null;
	}

	/**
	 * Creates the <code>ConsoleStreamDaemon</code> for passing data from the
	 * <code>LoggedCommand</code>'s InputStream to the Console.
	 */
	protected void createConsoleDaemon() {
		consoleDaemon = new ConsoleStreamDaemon(this);
	}

	/**
	 * Creates the <code>ErrorStreamDaemon</code> for passing data from the
	 * <code>LoggedCommand</code>'s ErrorStream to the Console and ErrorView.
	 */
	protected void createErrorDaemon(IErrorParser parser) {
		ErrorView errorView = null;
		IViewPart ivp = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().findView(ErrorView.ID);
		if(null != ivp && ivp instanceof ErrorView)
			errorView = ((ErrorView)ivp);
		errorDaemon = new ErrorStreamDaemon(this, errorView, parser);
	}

	/**
	 * Runs the provided command in this ScriptConsole instance.
	 * @param command The command and arguments to run.
	 * @param envVars The environment variables to use while running
	 * @param prompt The prompt to get the users password if needed.
	 * @param errorParser The parser to handle error messages generated by the command
	 */
	public void run(String[] command, String[] envVars, IPasswordPrompt prompt, IErrorParser errorParser) {
	    cmd = new ScpExec(command);
		this.stopCommand = new Runnable() {
			public void run() {
				ScpExec stop = new ScpExec(new String[]{getStopString()});
				stop.start();
			}
		};
	    this.run(cmd, errorParser);
	}

	/**
	 * Runs the provided command in this ScriptConsole instance on the current
	 * host.
	 * @param command The command and arguments to run.
	 * @param envVars The environment variables to use while running
	 * @param prompt The prompt to get the users password if needed.
	 * @param errorParser The parser to handle error messages generated by the command
	 * @since 1.2
	 */
	public void runLocally(String[] command, String[] envVars, IPasswordPrompt prompt, IErrorParser errorParser) {
		cmd = new LoggedCommand(command, envVars, prompt, 100);
		this.stopCommand = new Runnable() {
			public void run() {
				try {
					RuntimeProcessFactory.getFactory().exec(getStopString(), null, null);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		};
		this.run(cmd, errorParser);
	}

	private void run(LoggedCommand cmd, IErrorParser errorParser){
		createConsoleDaemon();
		if (errorParser != null)
			createErrorDaemon(errorParser);
	    if (errorDaemon != null)
	    	cmd.addErrorStreamListener(errorDaemon);
        cmd.addInputStreamListener(consoleDaemon);
        cmd.start();
        activate();
        ScriptConsoleManager.getInstance().activeConsoleChanged(this);
        ConsolePlugin.getDefault().getConsoleManager().showConsoleView(this);
	}

	/**
	 * Check to see if the Command is still running
	 * @return boolean representing if the command is running
	 */
	public boolean isRunning() {
		// If there is no command there is nothing running
		if (null == cmd) {
			return false;
		}
		return cmd.isRunning();
	}

	/**
	 * Check to see if this class has already been disposed.
	 * @return boolean representing whether or not the class has been disposed.
	 */
	public boolean isDisposed() {
		// If there is no command it can be considered disposed
		if (null == cmd) {
			return true;
		}
		return cmd.isDisposed();
	}

	/**
	 * Method to allow the user to save the Commands output to a file for use latter.
	 * @param file The new file to save the output to.
	 */
	public void saveStream(File file) {
		if (isRunning())
			if (!cmd.saveLog(file))
				MessageDialog
						.openWarning(
								PlatformUI.getWorkbench()
										.getActiveWorkbenchWindow().getShell(),
								Localization.getString("ScriptConsole.Problem"), Localization.getString("ScriptConsole.ErrorSavingLog")); //$NON-NLS-1$//$NON-NLS-2$
	}

	/**
	 * Gets the command that is running in this console, or null if there is no running command.
	 * @return The <code>LoggedCommand</code> that is running in this console.
	 */
	public LoggedCommand getCommand() {
		return cmd;
	}

	/**
	 * Stops the running command and the associated listeners.
	 */
	public synchronized void stop() {
		  if(isRunning()) {
			  // Remove the readers so the process is not blocked
			  // on writing to console
			  cmd.removeErrorStreamListener(errorDaemon);
			  cmd.removeInputStreamListener(consoleDaemon);

			  // Stop the underlying stap process
			  this.stopCommand.run();

			  // Stop the command
			  cmd.stop();
              setName(Localization.getString("ScriptConsole.Terminated") + super.getName()); //$NON-NLS-1$
		}
	}

	private String getModuleName(){
		if(this.moduleName == null){
			moduleName = this.getName();
			int lastSlash = moduleName.lastIndexOf('/')+1;
			if (lastSlash < 0){
				lastSlash = 0;
			}
			int lastDot = moduleName.indexOf(".stp"); //$NON-NLS-1$
			if (lastDot > 0){
				moduleName = moduleName.substring(lastSlash, lastDot);
			}
		}
		return this.moduleName;
	}

	private String getStopString(){
		  return "pkill -SIGINT -f stapio.*"+ getModuleName();  //$NON-NLS-1$
	}
	/**
	 * Disposes of all internal references in the class. No method should be called after this.
	 */
	@Override
	public void dispose() {
		if(!isDisposed()) {
			if(null != cmd)
				cmd.dispose();
			cmd = null;
			if(null != errorDaemon)
				errorDaemon.dispose();
			errorDaemon = null;
			if(null != consoleDaemon)
				consoleDaemon.dispose();
			consoleDaemon = null;
		}
	}

	/**
	 * Changes the name displayed on this console.
	 * @param name The new name to display on the console.
	 */
	@Override
	public void setName(String name) {
		super.setName(name);
		if(null != ConsolePlugin.getDefault())
			ConsolePlugin.getDefault().getConsoleManager().refresh(this);
	}
}